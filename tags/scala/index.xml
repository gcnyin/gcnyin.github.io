<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>scala on 箱子的博客</title><link>https://xiangzi.me/tags/scala/</link><description>Recent content in scala on 箱子的博客</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 22 Jul 2023 00:53:32 +0800</lastBuildDate><atom:link href="https://xiangzi.me/tags/scala/index.xml" rel="self" type="application/rss+xml"/><item><title>使用zio-http, quill与postgres开发web服务</title><link>https://xiangzi.me/post/20230722-zio-http-quill-postgres/</link><pubDate>Sat, 22 Jul 2023 00:53:32 +0800</pubDate><guid>https://xiangzi.me/post/20230722-zio-http-quill-postgres/</guid><description>本文面向有一定scala和zio基础的读者。 zio是用Scala语言开发的一套框架，核心功能是并发管理和资源管理，近年来在scala社区中逐</description></item><item><title>使用akka踩的一些坑</title><link>https://xiangzi.me/post/20210812-experience-using-akka/</link><pubDate>Thu, 12 Aug 2021 11:06:25 +0800</pubDate><guid>https://xiangzi.me/post/20210812-experience-using-akka/</guid><description>最近在学习 akka，踩了很多坑，这里分享给大家。 使用 akka-stream 限制并发度 原代码如下。 def fetchRlCnt(pageNumbers: Seq[Int]): Future[Int] = { val futures: Seq[Future[HttpResponse]] = pageNumbers .map(page =&amp;gt; Http() .singleRequest(HttpRequest(uri = s&amp;#34;https://examples.org/mix_list/$page&amp;#34;))) Future.sequence(futures) .map(_.map(Unmarshal(_).to[MixList])) .flatMap(Future.sequence(_)) .map(_.map(_.data.rl.length).sum) } 本意是请求所有的分页</description></item></channel></rss>