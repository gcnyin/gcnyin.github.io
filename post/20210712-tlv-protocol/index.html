<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>浅谈TLV协议的实现 | 箱子的博客</title>
<meta name="keywords" content="network">
<meta name="description" content="今天稍微聊点应用层网络协议设计。 简介 众所周知，tcp是一种面向字节流的协议，可以看作一条无尽的水流。如果对水流的内容不加区分，便完全不知道各">
<meta name="author" content="">
<link rel="canonical" href="https://xiangzi.me/post/20210712-tlv-protocol/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://xiangzi.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xiangzi.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xiangzi.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xiangzi.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://xiangzi.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://xiangzi.me/post/20210712-tlv-protocol/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://xiangzi.me/post/20210712-tlv-protocol/">
  <meta property="og:site_name" content="箱子的博客">
  <meta property="og:title" content="浅谈TLV协议的实现">
  <meta property="og:description" content="今天稍微聊点应用层网络协议设计。 简介 众所周知，tcp是一种面向字节流的协议，可以看作一条无尽的水流。如果对水流的内容不加区分，便完全不知道各">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2021-07-12T22:10:50+08:00">
    <meta property="article:modified_time" content="2021-07-12T22:10:50+08:00">
    <meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈TLV协议的实现">
<meta name="twitter:description" content="今天稍微聊点应用层网络协议设计。 简介 众所周知，tcp是一种面向字节流的协议，可以看作一条无尽的水流。如果对水流的内容不加区分，便完全不知道各">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xiangzi.me/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "浅谈TLV协议的实现",
      "item": "https://xiangzi.me/post/20210712-tlv-protocol/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "浅谈TLV协议的实现",
  "name": "浅谈TLV协议的实现",
  "description": "今天稍微聊点应用层网络协议设计。 简介 众所周知，tcp是一种面向字节流的协议，可以看作一条无尽的水流。如果对水流的内容不加区分，便完全不知道各",
  "keywords": [
    "network"
  ],
  "articleBody": "今天稍微聊点应用层网络协议设计。\n简介 众所周知，tcp是一种面向字节流的协议，可以看作一条无尽的水流。如果对水流的内容不加区分，便完全不知道各字节所代表的含义，进而无法处理。如此看来，设计一个能清晰划分字节流边界的应用层协议就显得非常必要。这便涉及到今天所讲的TLV协议。\nTLV全称Type–length–value，是大多数应用层协议的设计思路。主要内容包括\n最前面的若干位字节表明传统的是否为该协议（本文暂定为4个字节） 紧跟着若干字节（本文暂定为4个字节，也就是Java中的int），代表后续value的字节长度 最后是代表value的字节，其长度为2中所获得的数量 整个系统的状态机如图所示。\n实现 不同状态的Handler 用nio具体编写时，可以先抽象出一个Handler接口，可以接受一个byte进行处理。再添加三个实现（私有方法），代表0、1、2这三种状态对应的Handler。\ninterface Handler { int feed(byte b); } private int readType(byte b) { // TODO } private int readLength(byte b) { // TODO } private int readValue(byte b) { // TODO } 状态的定义 接着定义三种状态对应的code和一个Handler数组，这样后面可以用当前状态去取对应的Handler（handlers[state]）。state表示当前状态，初始值当然是TYPE_STATE。\nstatic final int TYPE_STATE = 0; static final int LENGTH_STATE = 1; static final int VALUE_STATE = 2; final Handler[] handlers = new Handler[]{ this::readType, this::readLength, this::readValue }; int state = TYPE_STATE; 对外接口 对外接口是read()，供外层在读事件就绪时调用。这里会不停地一个字节一个字节的读取ByteBuffer，并调用当前状态的Handler去处理。如果返回-1代表处理失败，需要关闭连接。\npublic void read() throws IOException { while (true) { int i = channel.read(buffer); if (i == -1) { close(); return; } if (i == 0) return; buffer.flip(); while (buffer.hasRemaining()) { byte b = buffer.get(); int f = handlers[state].feed(b); if (f == -1) { close(); return; } } buffer.clear(); } } 接受到的数据 接着定义若干byte[]，代表每个状态接收的字节，同时还有若干Pointer代表当前填充到第几个字节。注意，代表value的data并没有初始化，因为它的长度是根据length确定的。\nfinal byte[] type = new byte[4]; byte typePointer = 0; final byte[] length = new byte[4]; byte lengthPointer = 0; int dataLength = 0; byte[] data; readType Handler 接下来就可以实现之前提到的三个Handler了。先看readType，每次一次byte进来，它就会填充到type(byte[])的下一位，并判断是否满足长度，如果不满足则等待下一个byte。如果长度够4位了，但内容和约定的不一样，会返回-1，代表内容有误，供上层处理。如果长度和内容正确，那么状态就转移到LENGTH_STATE上，由下一个readLength Handler处理。\nprivate int readType(byte b) { type[typePointer] = b; if (typePointer != 3) { typePointer++; return 0; } typePointer = 0; if (!Arrays.equals(type, new byte[]{0x01, 0x23, 0x45, 0x67})) { return -1; } state = LENGTH_STATE; return 0; } readLength Handler readLength Handler和上面也是类似的，额外多了一步，将读取的value长度保存到dataLength字段中，并将状态转移到VALUE_STATE上。\nprivate int readLength(byte b) { length[lengthPointer] = b; if (lengthPointer != 3) { lengthPointer++; return 0; } lengthPointer = 0; dataLength = ByteBuffer.wrap(length).getInt(); if (dataLength == 0) { return -1; } data = new byte[dataLength]; state = VALUE_STATE; return 0; } readValue Handler readValue Handler将字节存储起来，直到数量和readLength中获得的dataLength值一样，之后就可以进行正常的业务逻辑处理，我这里是简单地print所有数据。\nprivate int readValue(byte b) { data[dataPointer] = b; if (dataPointer != dataLength - 1) { dataPointer++; return 0; } dataPointer = 0; process(); state = TYPE_STATE; return 0; } private void process() { if (data == null) return; String s = new String(data, StandardCharsets.UTF_8); System.out.println(s); } 总结 tlv协议的实现大致就是这样。实现一个状态机，根据输入，判断是否转移到下一步状态。本文的实现比较简单，value是作为请求的body存在的，如果需要，还可以加上Header或timeout处理之类额外的功能。\n原文代码在这里，里面除了TLV还有其他java nio的实践，欢迎交流。\n参考资料\nhttps://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value ",
  "wordCount" : "1446",
  "inLanguage": "en",
  "datePublished": "2021-07-12T22:10:50+08:00",
  "dateModified": "2021-07-12T22:10:50+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xiangzi.me/post/20210712-tlv-protocol/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "箱子的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xiangzi.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xiangzi.me/" accesskey="h" title="箱子的博客 (Alt + H)">箱子的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://xiangzi.me/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://xiangzi.me/post/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://xiangzi.me/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://xiangzi.me/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://xiangzi.me/page/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      浅谈TLV协议的实现
    </h1>
    <div class="post-meta"><span title='2021-07-12 22:10:50 +0800 +0800'>July 12, 2021</span>

</div>
  </header> 
  <div class="post-content"><p>今天稍微聊点应用层网络协议设计。</p>
<h1 id="简介">简介<a hidden class="anchor" aria-hidden="true" href="#简介">#</a></h1>
<p>众所周知，tcp是一种面向字节流的协议，可以看作一条无尽的水流。如果对水流的内容不加区分，便完全不知道各字节所代表的含义，进而无法处理。如此看来，设计一个能清晰划分字节流边界的应用层协议就显得非常必要。这便涉及到今天所讲的TLV协议。</p>
<p>TLV全称<a href="https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value">Type–length–value</a>，是大多数应用层协议的设计思路。主要内容包括</p>
<ol>
<li>最前面的若干位字节表明传统的是否为该协议（本文暂定为4个字节）</li>
<li>紧跟着若干字节（本文暂定为4个字节，也就是Java中的int），代表后续value的字节长度</li>
<li>最后是代表value的字节，其长度为2中所获得的数量</li>
</ol>
<p>整个系统的状态机如图所示。</p>
<p><img alt="tlv-state-machine" loading="lazy" src="/tlv-state-machine.png"></p>
<h1 id="实现">实现<a hidden class="anchor" aria-hidden="true" href="#实现">#</a></h1>
<h2 id="不同状态的handler">不同状态的Handler<a hidden class="anchor" aria-hidden="true" href="#不同状态的handler">#</a></h2>
<p>用nio具体编写时，可以先抽象出一个<code>Handler</code>接口，可以接受一个<code>byte</code>进行处理。再添加三个实现（私有方法），代表0、1、2这三种状态对应的<code>Handler</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Handler</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">feed</span>(<span style="color:#66d9ef">byte</span> b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readType</span>(<span style="color:#66d9ef">byte</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readLength</span>(<span style="color:#66d9ef">byte</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readValue</span>(<span style="color:#66d9ef">byte</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="状态的定义">状态的定义<a hidden class="anchor" aria-hidden="true" href="#状态的定义">#</a></h2>
<p>接着定义三种状态对应的code和一个<code>Handler</code>数组，这样后面可以用当前状态去取对应的<code>Handler</code>（<code>handlers[state]</code>）。<code>state</code>表示当前状态，初始值当然是<code>TYPE_STATE</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> TYPE_STATE <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> LENGTH_STATE <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> VALUE_STATE <span style="color:#f92672">=</span> 2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> Handler<span style="color:#f92672">[]</span> handlers <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Handler<span style="color:#f92672">[]</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>::readType,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>::readLength,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>::readValue
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> state <span style="color:#f92672">=</span> TYPE_STATE;
</span></span></code></pre></div><h2 id="对外接口">对外接口<a hidden class="anchor" aria-hidden="true" href="#对外接口">#</a></h2>
<p>对外接口是<code>read()</code>，供外层在读事件就绪时调用。这里会不停地一个字节一个字节的读取ByteBuffer，并调用当前状态的<code>Handler</code>去处理。如果返回<code>-1</code>代表处理失败，需要关闭连接。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>() <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> channel.<span style="color:#a6e22e">read</span>(buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>      close();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> 0) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    buffer.<span style="color:#a6e22e">flip</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (buffer.<span style="color:#a6e22e">hasRemaining</span>()) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">byte</span> b <span style="color:#f92672">=</span> buffer.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> f <span style="color:#f92672">=</span> handlers<span style="color:#f92672">[</span>state<span style="color:#f92672">]</span>.<span style="color:#a6e22e">feed</span>(b);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>        close();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    buffer.<span style="color:#a6e22e">clear</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="接受到的数据">接受到的数据<a hidden class="anchor" aria-hidden="true" href="#接受到的数据">#</a></h2>
<p>接着定义若干<code>byte[]</code>，代表每个状态接收的字节，同时还有若干<code>Pointer</code>代表当前填充到第几个字节。注意，代表<code>value</code>的<code>data</code>并没有初始化，因为它的长度是根据<code>length</code>确定的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> type <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">byte</span> typePointer <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> length <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">byte</span> lengthPointer <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dataLength <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> data;
</span></span></code></pre></div><h2 id="readtype-handler">readType Handler<a hidden class="anchor" aria-hidden="true" href="#readtype-handler">#</a></h2>
<p>接下来就可以实现之前提到的三个<code>Handler</code>了。先看<code>readType</code>，每次一次<code>byte</code>进来，它就会填充到<code>type</code>(byte[])的下一位，并判断是否满足长度，如果不满足则等待下一个byte。如果长度够4位了，但内容和约定的不一样，会返回<code>-1</code>，代表内容有误，供上层处理。如果长度和内容正确，那么状态就转移到<code>LENGTH_STATE</code>上，由下一个<code>readLength Handler</code>处理。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readType</span>(<span style="color:#66d9ef">byte</span> b) {
</span></span><span style="display:flex;"><span>  type<span style="color:#f92672">[</span>typePointer<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (typePointer <span style="color:#f92672">!=</span> 3) {
</span></span><span style="display:flex;"><span>    typePointer<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  typePointer <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>Arrays.<span style="color:#a6e22e">equals</span>(type, <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span>{0x01, 0x23, 0x45, 0x67})) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  state <span style="color:#f92672">=</span> LENGTH_STATE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="readlength-handler">readLength Handler<a hidden class="anchor" aria-hidden="true" href="#readlength-handler">#</a></h2>
<p><code>readLength Handler</code>和上面也是类似的，额外多了一步，将读取的value长度保存到<code>dataLength</code>字段中，并将状态转移到<code>VALUE_STATE</code>上。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readLength</span>(<span style="color:#66d9ef">byte</span> b) {
</span></span><span style="display:flex;"><span>  length<span style="color:#f92672">[</span>lengthPointer<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lengthPointer <span style="color:#f92672">!=</span> 3) {
</span></span><span style="display:flex;"><span>    lengthPointer<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  lengthPointer <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>  dataLength <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">wrap</span>(length).<span style="color:#a6e22e">getInt</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (dataLength <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>dataLength<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>  state <span style="color:#f92672">=</span> VALUE_STATE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="readvalue-handler">readValue Handler<a hidden class="anchor" aria-hidden="true" href="#readvalue-handler">#</a></h2>
<p><code>readValue Handler</code>将字节存储起来，直到数量和<code>readLength</code>中获得的<code>dataLength</code>值一样，之后就可以进行正常的业务逻辑处理，我这里是简单地print所有数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readValue</span>(<span style="color:#66d9ef">byte</span> b) {
</span></span><span style="display:flex;"><span>  data<span style="color:#f92672">[</span>dataPointer<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (dataPointer <span style="color:#f92672">!=</span> dataLength <span style="color:#f92672">-</span> 1) {
</span></span><span style="display:flex;"><span>    dataPointer<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  dataPointer <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>  process();
</span></span><span style="display:flex;"><span>  state <span style="color:#f92672">=</span> TYPE_STATE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">process</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>  String s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String(data, StandardCharsets.<span style="color:#a6e22e">UTF_8</span>);
</span></span><span style="display:flex;"><span>  System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(s);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h1>
<p>tlv协议的实现大致就是这样。实现一个状态机，根据输入，判断是否转移到下一步状态。本文的实现比较简单，<code>value</code>是作为请求的<code>body</code>存在的，如果需要，还可以加上<code>Header</code>或timeout处理之类额外的功能。</p>
<p>原文代码在<a href="https://github.com/gcnyin/raw-nio/blob/master/src/main/java/com/github/gcnyin/rawnio/tlv">这里</a>，里面除了TLV还有其他java nio的实践，欢迎交流。</p>
<p>参考资料</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value">https://en.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://xiangzi.me/tags/network/">Network</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://xiangzi.me/">箱子的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
